// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "game.v1";

export enum GameStage {
  GAME_STAGE_UNSPECIFIED = 0,
  GAME_STAGE_LOBBY = 1,
  GAME_STAGE_RUNNING = 2,
  UNRECOGNIZED = -1,
}

export function gameStageFromJSON(object: any): GameStage {
  switch (object) {
    case 0:
    case "GAME_STAGE_UNSPECIFIED":
      return GameStage.GAME_STAGE_UNSPECIFIED;
    case 1:
    case "GAME_STAGE_LOBBY":
      return GameStage.GAME_STAGE_LOBBY;
    case 2:
    case "GAME_STAGE_RUNNING":
      return GameStage.GAME_STAGE_RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameStage.UNRECOGNIZED;
  }
}

export function gameStageToJSON(object: GameStage): string {
  switch (object) {
    case GameStage.GAME_STAGE_UNSPECIFIED:
      return "GAME_STAGE_UNSPECIFIED";
    case GameStage.GAME_STAGE_LOBBY:
      return "GAME_STAGE_LOBBY";
    case GameStage.GAME_STAGE_RUNNING:
      return "GAME_STAGE_RUNNING";
    case GameStage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * PACKET: Client -> Server
 * Every message sent by the Host or Player comes wrapped in this.
 */
export interface WsClientPacket {
  packet?:
  | //
  /** Connection / Setup */
  { $case: "createRoom"; createRoom: CreateRoomRequest }
  | { $case: "joinRoom"; joinRoom: JoinRoomRequest }
  | { $case: "leaveRoom"; leaveRoom: LeaveRoomRequest }
  | { $case: "getTime"; getTime: GetServerTimeRequest }
  | //
  /** Host Actions */
  { $case: "updatePlayer"; updatePlayer: UpdatePlayerStateRequest }
  | { $case: "setStage"; setStage: SetGameStageRequest }
  | { $case: "sendMessage"; sendMessage: SendMessageRequest }
  | //
  /** Player Actions */
  { $case: "playerInput"; playerInput: SendPlayerInputRequest }
  | undefined;
}

/**
 * PACKET: Server -> Client
 * Every message received by the Host or Player comes wrapped in this.
 */
export interface WsServerPacket {
  packet?:
  | //
  /** Responses to specific requests */
  { $case: "createRoomResponse"; createRoomResponse: CreateRoomResponse }
  | { $case: "joinRoomResponse"; joinRoomResponse: JoinRoomResponse }
  | { $case: "getTimeResponse"; getTimeResponse: GetServerTimeResponse }
  | //
  /** Real-time Push Updates */
  { $case: "gameEvent"; gameEvent: GameEvent }
  | { $case: "playerInput"; playerInput: PlayerInput }
  | //
  /** Error handling */
  { $case: "error"; error: ErrorResponse }
  | undefined;
}

export interface ErrorResponse {
  message: string;
  code: number;
}

export interface Avatar {
  eyes: number;
  mouth: number;
  hair: number;
  emote: number;
}

export interface PlayerState {
  /** Acts as ID */
  name: string;
  score: number;
  /** Which screen the player is currently on */
  screen: string;
  /** JSON string payload for page info */
  pageDataJson: string;
  isAdmin: boolean;
  drinks: number;
  /** Timer info */
  timerStamp:
  | Date
  | undefined;
  /** in seconds or milliseconds */
  timerDuration: number;
  index: number;
  color: string;
  team: string;
  avatar: Avatar | undefined;
  isConnected: boolean;
}

export interface PlayerInputPayload {
  payload?:
  | { $case: "questionData"; questionData: QuestionData }
  | { $case: "promptData"; promptData: PromptData }
  | { $case: "dilemmaData"; dilemmaData: DilemmaData }
  | { $case: "instructionData"; instructionData: InstructionData }
  | { $case: "voteData"; voteData: VoteData }
  | { $case: "adminStartData"; adminStartData: AdminStartData }
  | { $case: "photoPickerData"; photoPickerData: PhotoPickerData }
  | { $case: "joystickData"; joystickData: JoystickData }
  | { $case: "avatarUpdate"; avatarUpdate: AvatarUpdate }
  | { $case: "startGame"; startGame: StartGame }
  | { $case: "emote"; emote: Emote }
  | { $case: "multipleChoice"; multipleChoice: MultipleChoice }
  | { $case: "restartGame"; restartGame: RestartGame }
  | { $case: "promptTextData"; promptTextData: PromptTextData }
  | { $case: "playerVoteData"; playerVoteData: PlayerVoteData }
  | undefined;
}

export interface AvatarUpdate {
  avatar: Avatar | undefined;
}

/** 60hz Realtime Data */
export interface JoystickData {
  /** Normalized coordinates (-1.0 to 1.0) */
  x: number;
  y: number;
  /** e.g. holding a button while moving */
  isPressed: boolean;
}

export interface MultipleChoice {
  answer: string;
}

export interface QuestionData {
  question: string;
  answers: string[];
}

export interface PromptData {
  question: string;
}

export interface PromptTextData {
  answer: string;
}

export interface DilemmaData {
  points: number;
}

export interface InstructionData {
  instruction: string;
}

export interface VoteData {
  options: string[];
}

export interface PlayerVoteData {
  answer: string;
}

export interface Settings {
  doubloons: number;
  rounds: number;
  endCondition: number;
  drinking: boolean;
  family: boolean;
}

export interface AdminStartData {
  settings: Settings | undefined;
}

export interface StartGame {
}

export interface Emote {
}

export interface RestartGame {
}

export interface PhotoPickerData {
  photoAmount: number;
  photoIndex: number;
}

export interface CreateRoomRequest {
}

export interface CreateRoomResponse {
  roomCode: string;
  hostToken: string;
}

export interface JoinRoomRequest {
  roomCode: string;
  playerName: string;
  /** For db */
  userId: string;
}

export interface JoinRoomResponse {
  playerToken: string;
  wasReconnection: boolean;
  snapshot: PlayerState | undefined;
}

export interface GetServerTimeRequest {
  /** Client can send their local timestamp to calculate round-trip time */
  clientTimestamp: number;
}

export interface GetServerTimeResponse {
  serverTime:
  | Date
  | undefined;
  /** Echoed back */
  clientTimestamp: number;
}

/** Push Events */
export interface GameEvent {
  event?: { $case: "fullSync"; fullSync: RoomState } | { $case: "playerUpdate"; playerUpdate: PlayerState } | {
    $case: "connectionChange";
    connectionChange: ConnectionChange;
  } | undefined;
}

export interface PlayerInput {
  playerName: string;
  input: PlayerInputPayload | undefined;
}

export interface RoomState {
  roomCode: string;
  stage: GameStage;
  players: PlayerState[];
}

export interface ConnectionChange {
  playerName: string;
  userId: string;
  isConnected: boolean;
}

export interface UpdatePlayerStateRequest {
  updates: { [key: string]: PlayerState };
}

export interface UpdatePlayerStateRequest_UpdatesEntry {
  key: string;
  value: PlayerState | undefined;
}

export interface SendMessageRequest {
  targetPlayer: string;
  message: string;
}

export interface SetGameStageRequest {
  roomCode: string;
  hostToken: string;
  stage: GameStage;
}

export interface SendPlayerInputRequest {
  /** Optional if server tracks socket->room mapping */
  roomCode: string;
  playerToken: string;
  input: PlayerInputPayload | undefined;
}

export interface LeaveRoomRequest {
  roomCode: string;
  playerToken: string;
}

function createBaseWsClientPacket(): WsClientPacket {
  return { packet: undefined };
}

export const WsClientPacket: MessageFns<WsClientPacket> = {
  encode(message: WsClientPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.packet?.$case) {
      case "createRoom":
        CreateRoomRequest.encode(message.packet.createRoom, writer.uint32(10).fork()).join();
        break;
      case "joinRoom":
        JoinRoomRequest.encode(message.packet.joinRoom, writer.uint32(18).fork()).join();
        break;
      case "leaveRoom":
        LeaveRoomRequest.encode(message.packet.leaveRoom, writer.uint32(26).fork()).join();
        break;
      case "getTime":
        GetServerTimeRequest.encode(message.packet.getTime, writer.uint32(34).fork()).join();
        break;
      case "updatePlayer":
        UpdatePlayerStateRequest.encode(message.packet.updatePlayer, writer.uint32(42).fork()).join();
        break;
      case "setStage":
        SetGameStageRequest.encode(message.packet.setStage, writer.uint32(50).fork()).join();
        break;
      case "sendMessage":
        SendMessageRequest.encode(message.packet.sendMessage, writer.uint32(58).fork()).join();
        break;
      case "playerInput":
        SendPlayerInputRequest.encode(message.packet.playerInput, writer.uint32(66).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WsClientPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWsClientPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packet = { $case: "createRoom", createRoom: CreateRoomRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packet = { $case: "joinRoom", joinRoom: JoinRoomRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packet = { $case: "leaveRoom", leaveRoom: LeaveRoomRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packet = { $case: "getTime", getTime: GetServerTimeRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.packet = {
            $case: "updatePlayer",
            updatePlayer: UpdatePlayerStateRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.packet = { $case: "setStage", setStage: SetGameStageRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.packet = { $case: "sendMessage", sendMessage: SendMessageRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.packet = {
            $case: "playerInput",
            playerInput: SendPlayerInputRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WsClientPacket {
    return {
      packet: isSet(object.createRoom)
        ? { $case: "createRoom", createRoom: CreateRoomRequest.fromJSON(object.createRoom) }
        : isSet(object.joinRoom)
          ? { $case: "joinRoom", joinRoom: JoinRoomRequest.fromJSON(object.joinRoom) }
          : isSet(object.leaveRoom)
            ? { $case: "leaveRoom", leaveRoom: LeaveRoomRequest.fromJSON(object.leaveRoom) }
            : isSet(object.getTime)
              ? { $case: "getTime", getTime: GetServerTimeRequest.fromJSON(object.getTime) }
              : isSet(object.updatePlayer)
                ? { $case: "updatePlayer", updatePlayer: UpdatePlayerStateRequest.fromJSON(object.updatePlayer) }
                : isSet(object.setStage)
                  ? { $case: "setStage", setStage: SetGameStageRequest.fromJSON(object.setStage) }
                  : isSet(object.sendMessage)
                    ? { $case: "sendMessage", sendMessage: SendMessageRequest.fromJSON(object.sendMessage) }
                    : isSet(object.playerInput)
                      ? { $case: "playerInput", playerInput: SendPlayerInputRequest.fromJSON(object.playerInput) }
                      : undefined,
    };
  },

  toJSON(message: WsClientPacket): unknown {
    const obj: any = {};
    if (message.packet?.$case === "createRoom") {
      obj.createRoom = CreateRoomRequest.toJSON(message.packet.createRoom);
    } else if (message.packet?.$case === "joinRoom") {
      obj.joinRoom = JoinRoomRequest.toJSON(message.packet.joinRoom);
    } else if (message.packet?.$case === "leaveRoom") {
      obj.leaveRoom = LeaveRoomRequest.toJSON(message.packet.leaveRoom);
    } else if (message.packet?.$case === "getTime") {
      obj.getTime = GetServerTimeRequest.toJSON(message.packet.getTime);
    } else if (message.packet?.$case === "updatePlayer") {
      obj.updatePlayer = UpdatePlayerStateRequest.toJSON(message.packet.updatePlayer);
    } else if (message.packet?.$case === "setStage") {
      obj.setStage = SetGameStageRequest.toJSON(message.packet.setStage);
    } else if (message.packet?.$case === "sendMessage") {
      obj.sendMessage = SendMessageRequest.toJSON(message.packet.sendMessage);
    } else if (message.packet?.$case === "playerInput") {
      obj.playerInput = SendPlayerInputRequest.toJSON(message.packet.playerInput);
    }
    return obj;
  },

  create(base?: DeepPartial<WsClientPacket>): WsClientPacket {
    return WsClientPacket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WsClientPacket>): WsClientPacket {
    const message = createBaseWsClientPacket();
    switch (object.packet?.$case) {
      case "createRoom": {
        if (object.packet?.createRoom !== undefined && object.packet?.createRoom !== null) {
          message.packet = { $case: "createRoom", createRoom: CreateRoomRequest.fromPartial(object.packet.createRoom) };
        }
        break;
      }
      case "joinRoom": {
        if (object.packet?.joinRoom !== undefined && object.packet?.joinRoom !== null) {
          message.packet = { $case: "joinRoom", joinRoom: JoinRoomRequest.fromPartial(object.packet.joinRoom) };
        }
        break;
      }
      case "leaveRoom": {
        if (object.packet?.leaveRoom !== undefined && object.packet?.leaveRoom !== null) {
          message.packet = { $case: "leaveRoom", leaveRoom: LeaveRoomRequest.fromPartial(object.packet.leaveRoom) };
        }
        break;
      }
      case "getTime": {
        if (object.packet?.getTime !== undefined && object.packet?.getTime !== null) {
          message.packet = { $case: "getTime", getTime: GetServerTimeRequest.fromPartial(object.packet.getTime) };
        }
        break;
      }
      case "updatePlayer": {
        if (object.packet?.updatePlayer !== undefined && object.packet?.updatePlayer !== null) {
          message.packet = {
            $case: "updatePlayer",
            updatePlayer: UpdatePlayerStateRequest.fromPartial(object.packet.updatePlayer),
          };
        }
        break;
      }
      case "setStage": {
        if (object.packet?.setStage !== undefined && object.packet?.setStage !== null) {
          message.packet = { $case: "setStage", setStage: SetGameStageRequest.fromPartial(object.packet.setStage) };
        }
        break;
      }
      case "sendMessage": {
        if (object.packet?.sendMessage !== undefined && object.packet?.sendMessage !== null) {
          message.packet = {
            $case: "sendMessage",
            sendMessage: SendMessageRequest.fromPartial(object.packet.sendMessage),
          };
        }
        break;
      }
      case "playerInput": {
        if (object.packet?.playerInput !== undefined && object.packet?.playerInput !== null) {
          message.packet = {
            $case: "playerInput",
            playerInput: SendPlayerInputRequest.fromPartial(object.packet.playerInput),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseWsServerPacket(): WsServerPacket {
  return { packet: undefined };
}

export const WsServerPacket: MessageFns<WsServerPacket> = {
  encode(message: WsServerPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.packet?.$case) {
      case "createRoomResponse":
        CreateRoomResponse.encode(message.packet.createRoomResponse, writer.uint32(10).fork()).join();
        break;
      case "joinRoomResponse":
        JoinRoomResponse.encode(message.packet.joinRoomResponse, writer.uint32(18).fork()).join();
        break;
      case "getTimeResponse":
        GetServerTimeResponse.encode(message.packet.getTimeResponse, writer.uint32(26).fork()).join();
        break;
      case "gameEvent":
        GameEvent.encode(message.packet.gameEvent, writer.uint32(34).fork()).join();
        break;
      case "playerInput":
        PlayerInput.encode(message.packet.playerInput, writer.uint32(42).fork()).join();
        break;
      case "error":
        ErrorResponse.encode(message.packet.error, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WsServerPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWsServerPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packet = {
            $case: "createRoomResponse",
            createRoomResponse: CreateRoomResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packet = {
            $case: "joinRoomResponse",
            joinRoomResponse: JoinRoomResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packet = {
            $case: "getTimeResponse",
            getTimeResponse: GetServerTimeResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packet = { $case: "gameEvent", gameEvent: GameEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.packet = { $case: "playerInput", playerInput: PlayerInput.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.packet = { $case: "error", error: ErrorResponse.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WsServerPacket {
    return {
      packet: isSet(object.createRoomResponse)
        ? { $case: "createRoomResponse", createRoomResponse: CreateRoomResponse.fromJSON(object.createRoomResponse) }
        : isSet(object.joinRoomResponse)
          ? { $case: "joinRoomResponse", joinRoomResponse: JoinRoomResponse.fromJSON(object.joinRoomResponse) }
          : isSet(object.getTimeResponse)
            ? { $case: "getTimeResponse", getTimeResponse: GetServerTimeResponse.fromJSON(object.getTimeResponse) }
            : isSet(object.gameEvent)
              ? { $case: "gameEvent", gameEvent: GameEvent.fromJSON(object.gameEvent) }
              : isSet(object.playerInput)
                ? { $case: "playerInput", playerInput: PlayerInput.fromJSON(object.playerInput) }
                : isSet(object.error)
                  ? { $case: "error", error: ErrorResponse.fromJSON(object.error) }
                  : undefined,
    };
  },

  toJSON(message: WsServerPacket): unknown {
    const obj: any = {};
    if (message.packet?.$case === "createRoomResponse") {
      obj.createRoomResponse = CreateRoomResponse.toJSON(message.packet.createRoomResponse);
    } else if (message.packet?.$case === "joinRoomResponse") {
      obj.joinRoomResponse = JoinRoomResponse.toJSON(message.packet.joinRoomResponse);
    } else if (message.packet?.$case === "getTimeResponse") {
      obj.getTimeResponse = GetServerTimeResponse.toJSON(message.packet.getTimeResponse);
    } else if (message.packet?.$case === "gameEvent") {
      obj.gameEvent = GameEvent.toJSON(message.packet.gameEvent);
    } else if (message.packet?.$case === "playerInput") {
      obj.playerInput = PlayerInput.toJSON(message.packet.playerInput);
    } else if (message.packet?.$case === "error") {
      obj.error = ErrorResponse.toJSON(message.packet.error);
    }
    return obj;
  },

  create(base?: DeepPartial<WsServerPacket>): WsServerPacket {
    return WsServerPacket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WsServerPacket>): WsServerPacket {
    const message = createBaseWsServerPacket();
    switch (object.packet?.$case) {
      case "createRoomResponse": {
        if (object.packet?.createRoomResponse !== undefined && object.packet?.createRoomResponse !== null) {
          message.packet = {
            $case: "createRoomResponse",
            createRoomResponse: CreateRoomResponse.fromPartial(object.packet.createRoomResponse),
          };
        }
        break;
      }
      case "joinRoomResponse": {
        if (object.packet?.joinRoomResponse !== undefined && object.packet?.joinRoomResponse !== null) {
          message.packet = {
            $case: "joinRoomResponse",
            joinRoomResponse: JoinRoomResponse.fromPartial(object.packet.joinRoomResponse),
          };
        }
        break;
      }
      case "getTimeResponse": {
        if (object.packet?.getTimeResponse !== undefined && object.packet?.getTimeResponse !== null) {
          message.packet = {
            $case: "getTimeResponse",
            getTimeResponse: GetServerTimeResponse.fromPartial(object.packet.getTimeResponse),
          };
        }
        break;
      }
      case "gameEvent": {
        if (object.packet?.gameEvent !== undefined && object.packet?.gameEvent !== null) {
          message.packet = { $case: "gameEvent", gameEvent: GameEvent.fromPartial(object.packet.gameEvent) };
        }
        break;
      }
      case "playerInput": {
        if (object.packet?.playerInput !== undefined && object.packet?.playerInput !== null) {
          message.packet = { $case: "playerInput", playerInput: PlayerInput.fromPartial(object.packet.playerInput) };
        }
        break;
      }
      case "error": {
        if (object.packet?.error !== undefined && object.packet?.error !== null) {
          message.packet = { $case: "error", error: ErrorResponse.fromPartial(object.packet.error) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { message: "", code: 0 };
}

export const ErrorResponse: MessageFns<ErrorResponse> = {
  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorResponse>): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorResponse>): ErrorResponse {
    const message = createBaseErrorResponse();
    message.message = object.message ?? "";
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseAvatar(): Avatar {
  return { eyes: 0, mouth: 0, hair: 0, emote: 0 };
}

export const Avatar: MessageFns<Avatar> = {
  encode(message: Avatar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eyes !== 0) {
      writer.uint32(8).int32(message.eyes);
    }
    if (message.mouth !== 0) {
      writer.uint32(16).int32(message.mouth);
    }
    if (message.hair !== 0) {
      writer.uint32(24).int32(message.hair);
    }
    if (message.emote !== 0) {
      writer.uint32(32).int32(message.emote);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Avatar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eyes = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mouth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hair = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.emote = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Avatar {
    return {
      eyes: isSet(object.eyes) ? globalThis.Number(object.eyes) : 0,
      mouth: isSet(object.mouth) ? globalThis.Number(object.mouth) : 0,
      hair: isSet(object.hair) ? globalThis.Number(object.hair) : 0,
      emote: isSet(object.emote) ? globalThis.Number(object.emote) : 0,
    };
  },

  toJSON(message: Avatar): unknown {
    const obj: any = {};
    if (message.eyes !== 0) {
      obj.eyes = Math.round(message.eyes);
    }
    if (message.mouth !== 0) {
      obj.mouth = Math.round(message.mouth);
    }
    if (message.hair !== 0) {
      obj.hair = Math.round(message.hair);
    }
    if (message.emote !== 0) {
      obj.emote = Math.round(message.emote);
    }
    return obj;
  },

  create(base?: DeepPartial<Avatar>): Avatar {
    return Avatar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Avatar>): Avatar {
    const message = createBaseAvatar();
    message.eyes = object.eyes ?? 0;
    message.mouth = object.mouth ?? 0;
    message.hair = object.hair ?? 0;
    message.emote = object.emote ?? 0;
    return message;
  },
};

function createBasePlayerState(): PlayerState {
  return {
    name: "",
    score: 0,
    screen: "",
    pageDataJson: "",
    isAdmin: false,
    drinks: 0,
    timerStamp: undefined,
    timerDuration: 0,
    index: 0,
    color: "",
    team: "",
    avatar: undefined,
    isConnected: false,
  };
}

export const PlayerState: MessageFns<PlayerState> = {
  encode(message: PlayerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.score !== 0) {
      writer.uint32(16).int32(message.score);
    }
    if (message.screen !== "") {
      writer.uint32(26).string(message.screen);
    }
    if (message.pageDataJson !== "") {
      writer.uint32(34).string(message.pageDataJson);
    }
    if (message.isAdmin !== false) {
      writer.uint32(40).bool(message.isAdmin);
    }
    if (message.drinks !== 0) {
      writer.uint32(48).int32(message.drinks);
    }
    if (message.timerStamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timerStamp), writer.uint32(58).fork()).join();
    }
    if (message.timerDuration !== 0) {
      writer.uint32(64).int32(message.timerDuration);
    }
    if (message.index !== 0) {
      writer.uint32(72).int32(message.index);
    }
    if (message.color !== "") {
      writer.uint32(82).string(message.color);
    }
    if (message.team !== "") {
      writer.uint32(90).string(message.team);
    }
    if (message.avatar !== undefined) {
      Avatar.encode(message.avatar, writer.uint32(98).fork()).join();
    }
    if (message.isConnected !== false) {
      writer.uint32(104).bool(message.isConnected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.screen = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pageDataJson = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.drinks = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timerStamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.timerDuration = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.avatar = Avatar.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isConnected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      screen: isSet(object.screen) ? globalThis.String(object.screen) : "",
      pageDataJson: isSet(object.pageDataJson) ? globalThis.String(object.pageDataJson) : "",
      isAdmin: isSet(object.isAdmin) ? globalThis.Boolean(object.isAdmin) : false,
      drinks: isSet(object.drinks) ? globalThis.Number(object.drinks) : 0,
      timerStamp: isSet(object.timerStamp) ? fromJsonTimestamp(object.timerStamp) : undefined,
      timerDuration: isSet(object.timerDuration) ? globalThis.Number(object.timerDuration) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      avatar: isSet(object.avatar) ? Avatar.fromJSON(object.avatar) : undefined,
      isConnected: isSet(object.isConnected) ? globalThis.Boolean(object.isConnected) : false,
    };
  },

  toJSON(message: PlayerState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.screen !== "") {
      obj.screen = message.screen;
    }
    if (message.pageDataJson !== "") {
      obj.pageDataJson = message.pageDataJson;
    }
    if (message.isAdmin !== false) {
      obj.isAdmin = message.isAdmin;
    }
    if (message.drinks !== 0) {
      obj.drinks = Math.round(message.drinks);
    }
    if (message.timerStamp !== undefined) {
      obj.timerStamp = message.timerStamp.toISOString();
    }
    if (message.timerDuration !== 0) {
      obj.timerDuration = Math.round(message.timerDuration);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.avatar !== undefined) {
      obj.avatar = Avatar.toJSON(message.avatar);
    }
    if (message.isConnected !== false) {
      obj.isConnected = message.isConnected;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerState>): PlayerState {
    return PlayerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerState>): PlayerState {
    const message = createBasePlayerState();
    message.name = object.name ?? "";
    message.score = object.score ?? 0;
    message.screen = object.screen ?? "";
    message.pageDataJson = object.pageDataJson ?? "";
    message.isAdmin = object.isAdmin ?? false;
    message.drinks = object.drinks ?? 0;
    message.timerStamp = object.timerStamp ?? undefined;
    message.timerDuration = object.timerDuration ?? 0;
    message.index = object.index ?? 0;
    message.color = object.color ?? "";
    message.team = object.team ?? "";
    message.avatar = (object.avatar !== undefined && object.avatar !== null)
      ? Avatar.fromPartial(object.avatar)
      : undefined;
    message.isConnected = object.isConnected ?? false;
    return message;
  },
};

function createBasePlayerInputPayload(): PlayerInputPayload {
  return { payload: undefined };
}

export const PlayerInputPayload: MessageFns<PlayerInputPayload> = {
  encode(message: PlayerInputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "questionData":
        QuestionData.encode(message.payload.questionData, writer.uint32(10).fork()).join();
        break;
      case "promptData":
        PromptData.encode(message.payload.promptData, writer.uint32(18).fork()).join();
        break;
      case "dilemmaData":
        DilemmaData.encode(message.payload.dilemmaData, writer.uint32(26).fork()).join();
        break;
      case "instructionData":
        InstructionData.encode(message.payload.instructionData, writer.uint32(34).fork()).join();
        break;
      case "voteData":
        VoteData.encode(message.payload.voteData, writer.uint32(42).fork()).join();
        break;
      case "adminStartData":
        AdminStartData.encode(message.payload.adminStartData, writer.uint32(50).fork()).join();
        break;
      case "photoPickerData":
        PhotoPickerData.encode(message.payload.photoPickerData, writer.uint32(58).fork()).join();
        break;
      case "joystickData":
        JoystickData.encode(message.payload.joystickData, writer.uint32(66).fork()).join();
        break;
      case "avatarUpdate":
        AvatarUpdate.encode(message.payload.avatarUpdate, writer.uint32(74).fork()).join();
        break;
      case "startGame":
        StartGame.encode(message.payload.startGame, writer.uint32(82).fork()).join();
        break;
      case "emote":
        Emote.encode(message.payload.emote, writer.uint32(90).fork()).join();
        break;
      case "multipleChoice":
        MultipleChoice.encode(message.payload.multipleChoice, writer.uint32(98).fork()).join();
        break;
      case "restartGame":
        RestartGame.encode(message.payload.restartGame, writer.uint32(106).fork()).join();
        break;
      case "promptTextData":
        PromptTextData.encode(message.payload.promptTextData, writer.uint32(114).fork()).join();
        break;
      case "playerVoteData":
        PlayerVoteData.encode(message.payload.playerVoteData, writer.uint32(122).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerInputPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerInputPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "questionData", questionData: QuestionData.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "promptData", promptData: PromptData.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = { $case: "dilemmaData", dilemmaData: DilemmaData.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = {
            $case: "instructionData",
            instructionData: InstructionData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = { $case: "voteData", voteData: VoteData.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payload = { $case: "adminStartData", adminStartData: AdminStartData.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payload = {
            $case: "photoPickerData",
            photoPickerData: PhotoPickerData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = { $case: "joystickData", joystickData: JoystickData.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.payload = { $case: "avatarUpdate", avatarUpdate: AvatarUpdate.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payload = { $case: "startGame", startGame: StartGame.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.payload = { $case: "emote", emote: Emote.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.payload = { $case: "multipleChoice", multipleChoice: MultipleChoice.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.payload = { $case: "restartGame", restartGame: RestartGame.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.payload = { $case: "promptTextData", promptTextData: PromptTextData.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.payload = { $case: "playerVoteData", playerVoteData: PlayerVoteData.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerInputPayload {
    return {
      payload: isSet(object.questionData)
        ? { $case: "questionData", questionData: QuestionData.fromJSON(object.questionData) }
        : isSet(object.promptData)
          ? { $case: "promptData", promptData: PromptData.fromJSON(object.promptData) }
          : isSet(object.dilemmaData)
            ? { $case: "dilemmaData", dilemmaData: DilemmaData.fromJSON(object.dilemmaData) }
            : isSet(object.instructionData)
              ? { $case: "instructionData", instructionData: InstructionData.fromJSON(object.instructionData) }
              : isSet(object.voteData)
                ? { $case: "voteData", voteData: VoteData.fromJSON(object.voteData) }
                : isSet(object.adminStartData)
                  ? { $case: "adminStartData", adminStartData: AdminStartData.fromJSON(object.adminStartData) }
                  : isSet(object.photoPickerData)
                    ? { $case: "photoPickerData", photoPickerData: PhotoPickerData.fromJSON(object.photoPickerData) }
                    : isSet(object.joystickData)
                      ? { $case: "joystickData", joystickData: JoystickData.fromJSON(object.joystickData) }
                      : isSet(object.avatarUpdate)
                        ? { $case: "avatarUpdate", avatarUpdate: AvatarUpdate.fromJSON(object.avatarUpdate) }
                        : isSet(object.startGame)
                          ? { $case: "startGame", startGame: StartGame.fromJSON(object.startGame) }
                          : isSet(object.emote)
                            ? { $case: "emote", emote: Emote.fromJSON(object.emote) }
                            : isSet(object.multipleChoice)
                              ? { $case: "multipleChoice", multipleChoice: MultipleChoice.fromJSON(object.multipleChoice) }
                              : isSet(object.restartGame)
                                ? { $case: "restartGame", restartGame: RestartGame.fromJSON(object.restartGame) }
                                : isSet(object.promptTextData)
                                  ? { $case: "promptTextData", promptTextData: PromptTextData.fromJSON(object.promptTextData) }
                                  : isSet(object.playerVoteData)
                                    ? { $case: "playerVoteData", playerVoteData: PlayerVoteData.fromJSON(object.playerVoteData) }
                                    : undefined,
    };
  },

  toJSON(message: PlayerInputPayload): unknown {
    const obj: any = {};
    if (message.payload?.$case === "questionData") {
      obj.questionData = QuestionData.toJSON(message.payload.questionData);
    } else if (message.payload?.$case === "promptData") {
      obj.promptData = PromptData.toJSON(message.payload.promptData);
    } else if (message.payload?.$case === "dilemmaData") {
      obj.dilemmaData = DilemmaData.toJSON(message.payload.dilemmaData);
    } else if (message.payload?.$case === "instructionData") {
      obj.instructionData = InstructionData.toJSON(message.payload.instructionData);
    } else if (message.payload?.$case === "voteData") {
      obj.voteData = VoteData.toJSON(message.payload.voteData);
    } else if (message.payload?.$case === "adminStartData") {
      obj.adminStartData = AdminStartData.toJSON(message.payload.adminStartData);
    } else if (message.payload?.$case === "photoPickerData") {
      obj.photoPickerData = PhotoPickerData.toJSON(message.payload.photoPickerData);
    } else if (message.payload?.$case === "joystickData") {
      obj.joystickData = JoystickData.toJSON(message.payload.joystickData);
    } else if (message.payload?.$case === "avatarUpdate") {
      obj.avatarUpdate = AvatarUpdate.toJSON(message.payload.avatarUpdate);
    } else if (message.payload?.$case === "startGame") {
      obj.startGame = StartGame.toJSON(message.payload.startGame);
    } else if (message.payload?.$case === "emote") {
      obj.emote = Emote.toJSON(message.payload.emote);
    } else if (message.payload?.$case === "multipleChoice") {
      obj.multipleChoice = MultipleChoice.toJSON(message.payload.multipleChoice);
    } else if (message.payload?.$case === "restartGame") {
      obj.restartGame = RestartGame.toJSON(message.payload.restartGame);
    } else if (message.payload?.$case === "promptTextData") {
      obj.promptTextData = PromptTextData.toJSON(message.payload.promptTextData);
    } else if (message.payload?.$case === "playerVoteData") {
      obj.playerVoteData = PlayerVoteData.toJSON(message.payload.playerVoteData);
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerInputPayload>): PlayerInputPayload {
    return PlayerInputPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerInputPayload>): PlayerInputPayload {
    const message = createBasePlayerInputPayload();
    switch (object.payload?.$case) {
      case "questionData": {
        if (object.payload?.questionData !== undefined && object.payload?.questionData !== null) {
          message.payload = {
            $case: "questionData",
            questionData: QuestionData.fromPartial(object.payload.questionData),
          };
        }
        break;
      }
      case "promptData": {
        if (object.payload?.promptData !== undefined && object.payload?.promptData !== null) {
          message.payload = { $case: "promptData", promptData: PromptData.fromPartial(object.payload.promptData) };
        }
        break;
      }
      case "dilemmaData": {
        if (object.payload?.dilemmaData !== undefined && object.payload?.dilemmaData !== null) {
          message.payload = { $case: "dilemmaData", dilemmaData: DilemmaData.fromPartial(object.payload.dilemmaData) };
        }
        break;
      }
      case "instructionData": {
        if (object.payload?.instructionData !== undefined && object.payload?.instructionData !== null) {
          message.payload = {
            $case: "instructionData",
            instructionData: InstructionData.fromPartial(object.payload.instructionData),
          };
        }
        break;
      }
      case "voteData": {
        if (object.payload?.voteData !== undefined && object.payload?.voteData !== null) {
          message.payload = { $case: "voteData", voteData: VoteData.fromPartial(object.payload.voteData) };
        }
        break;
      }
      case "adminStartData": {
        if (object.payload?.adminStartData !== undefined && object.payload?.adminStartData !== null) {
          message.payload = {
            $case: "adminStartData",
            adminStartData: AdminStartData.fromPartial(object.payload.adminStartData),
          };
        }
        break;
      }
      case "photoPickerData": {
        if (object.payload?.photoPickerData !== undefined && object.payload?.photoPickerData !== null) {
          message.payload = {
            $case: "photoPickerData",
            photoPickerData: PhotoPickerData.fromPartial(object.payload.photoPickerData),
          };
        }
        break;
      }
      case "joystickData": {
        if (object.payload?.joystickData !== undefined && object.payload?.joystickData !== null) {
          message.payload = {
            $case: "joystickData",
            joystickData: JoystickData.fromPartial(object.payload.joystickData),
          };
        }
        break;
      }
      case "avatarUpdate": {
        if (object.payload?.avatarUpdate !== undefined && object.payload?.avatarUpdate !== null) {
          message.payload = {
            $case: "avatarUpdate",
            avatarUpdate: AvatarUpdate.fromPartial(object.payload.avatarUpdate),
          };
        }
        break;
      }
      case "startGame": {
        if (object.payload?.startGame !== undefined && object.payload?.startGame !== null) {
          message.payload = { $case: "startGame", startGame: StartGame.fromPartial(object.payload.startGame) };
        }
        break;
      }
      case "emote": {
        if (object.payload?.emote !== undefined && object.payload?.emote !== null) {
          message.payload = { $case: "emote", emote: Emote.fromPartial(object.payload.emote) };
        }
        break;
      }
      case "multipleChoice": {
        if (object.payload?.multipleChoice !== undefined && object.payload?.multipleChoice !== null) {
          message.payload = {
            $case: "multipleChoice",
            multipleChoice: MultipleChoice.fromPartial(object.payload.multipleChoice),
          };
        }
        break;
      }
      case "restartGame": {
        if (object.payload?.restartGame !== undefined && object.payload?.restartGame !== null) {
          message.payload = { $case: "restartGame", restartGame: RestartGame.fromPartial(object.payload.restartGame) };
        }
        break;
      }
      case "promptTextData": {
        if (object.payload?.promptTextData !== undefined && object.payload?.promptTextData !== null) {
          message.payload = {
            $case: "promptTextData",
            promptTextData: PromptTextData.fromPartial(object.payload.promptTextData),
          };
        }
        break;
      }
      case "playerVoteData": {
        if (object.payload?.playerVoteData !== undefined && object.payload?.playerVoteData !== null) {
          message.payload = {
            $case: "playerVoteData",
            playerVoteData: PlayerVoteData.fromPartial(object.payload.playerVoteData),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAvatarUpdate(): AvatarUpdate {
  return { avatar: undefined };
}

export const AvatarUpdate: MessageFns<AvatarUpdate> = {
  encode(message: AvatarUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avatar !== undefined) {
      Avatar.encode(message.avatar, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvatarUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.avatar = Avatar.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvatarUpdate {
    return { avatar: isSet(object.avatar) ? Avatar.fromJSON(object.avatar) : undefined };
  },

  toJSON(message: AvatarUpdate): unknown {
    const obj: any = {};
    if (message.avatar !== undefined) {
      obj.avatar = Avatar.toJSON(message.avatar);
    }
    return obj;
  },

  create(base?: DeepPartial<AvatarUpdate>): AvatarUpdate {
    return AvatarUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvatarUpdate>): AvatarUpdate {
    const message = createBaseAvatarUpdate();
    message.avatar = (object.avatar !== undefined && object.avatar !== null)
      ? Avatar.fromPartial(object.avatar)
      : undefined;
    return message;
  },
};

function createBaseJoystickData(): JoystickData {
  return { x: 0, y: 0, isPressed: false };
}

export const JoystickData: MessageFns<JoystickData> = {
  encode(message: JoystickData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    if (message.isPressed !== false) {
      writer.uint32(24).bool(message.isPressed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoystickData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoystickData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isPressed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoystickData {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      isPressed: isSet(object.isPressed) ? globalThis.Boolean(object.isPressed) : false,
    };
  },

  toJSON(message: JoystickData): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.isPressed !== false) {
      obj.isPressed = message.isPressed;
    }
    return obj;
  },

  create(base?: DeepPartial<JoystickData>): JoystickData {
    return JoystickData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoystickData>): JoystickData {
    const message = createBaseJoystickData();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.isPressed = object.isPressed ?? false;
    return message;
  },
};

function createBaseMultipleChoice(): MultipleChoice {
  return { answer: "" };
}

export const MultipleChoice: MessageFns<MultipleChoice> = {
  encode(message: MultipleChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleChoice {
    return { answer: isSet(object.answer) ? globalThis.String(object.answer) : "" };
  },

  toJSON(message: MultipleChoice): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create(base?: DeepPartial<MultipleChoice>): MultipleChoice {
    return MultipleChoice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultipleChoice>): MultipleChoice {
    const message = createBaseMultipleChoice();
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseQuestionData(): QuestionData {
  return { question: "", answers: [] };
}

export const QuestionData: MessageFns<QuestionData> = {
  encode(message: QuestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(10).string(message.question);
    }
    for (const v of message.answers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.answers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionData {
    return {
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      answers: globalThis.Array.isArray(object?.answers) ? object.answers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QuestionData): unknown {
    const obj: any = {};
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.answers?.length) {
      obj.answers = message.answers;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionData>): QuestionData {
    return QuestionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionData>): QuestionData {
    const message = createBaseQuestionData();
    message.question = object.question ?? "";
    message.answers = object.answers?.map((e) => e) || [];
    return message;
  },
};

function createBasePromptData(): PromptData {
  return { question: "" };
}

export const PromptData: MessageFns<PromptData> = {
  encode(message: PromptData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(10).string(message.question);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptData {
    return { question: isSet(object.question) ? globalThis.String(object.question) : "" };
  },

  toJSON(message: PromptData): unknown {
    const obj: any = {};
    if (message.question !== "") {
      obj.question = message.question;
    }
    return obj;
  },

  create(base?: DeepPartial<PromptData>): PromptData {
    return PromptData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromptData>): PromptData {
    const message = createBasePromptData();
    message.question = object.question ?? "";
    return message;
  },
};

function createBasePromptTextData(): PromptTextData {
  return { answer: "" };
}

export const PromptTextData: MessageFns<PromptTextData> = {
  encode(message: PromptTextData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptTextData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptTextData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptTextData {
    return { answer: isSet(object.answer) ? globalThis.String(object.answer) : "" };
  },

  toJSON(message: PromptTextData): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create(base?: DeepPartial<PromptTextData>): PromptTextData {
    return PromptTextData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromptTextData>): PromptTextData {
    const message = createBasePromptTextData();
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseDilemmaData(): DilemmaData {
  return { points: 0 };
}

export const DilemmaData: MessageFns<DilemmaData> = {
  encode(message: DilemmaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== 0) {
      writer.uint32(8).int32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DilemmaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDilemmaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.points = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DilemmaData {
    return { points: isSet(object.points) ? globalThis.Number(object.points) : 0 };
  },

  toJSON(message: DilemmaData): unknown {
    const obj: any = {};
    if (message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    return obj;
  },

  create(base?: DeepPartial<DilemmaData>): DilemmaData {
    return DilemmaData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DilemmaData>): DilemmaData {
    const message = createBaseDilemmaData();
    message.points = object.points ?? 0;
    return message;
  },
};

function createBaseInstructionData(): InstructionData {
  return { instruction: "" };
}

export const InstructionData: MessageFns<InstructionData> = {
  encode(message: InstructionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instruction !== "") {
      writer.uint32(10).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstructionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instruction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructionData {
    return { instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : "" };
  },

  toJSON(message: InstructionData): unknown {
    const obj: any = {};
    if (message.instruction !== "") {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<InstructionData>): InstructionData {
    return InstructionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstructionData>): InstructionData {
    const message = createBaseInstructionData();
    message.instruction = object.instruction ?? "";
    return message;
  },
};

function createBaseVoteData(): VoteData {
  return { options: [] };
}

export const VoteData: MessageFns<VoteData> = {
  encode(message: VoteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.options) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.options.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteData {
    return {
      options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: VoteData): unknown {
    const obj: any = {};
    if (message.options?.length) {
      obj.options = message.options;
    }
    return obj;
  },

  create(base?: DeepPartial<VoteData>): VoteData {
    return VoteData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoteData>): VoteData {
    const message = createBaseVoteData();
    message.options = object.options?.map((e) => e) || [];
    return message;
  },
};

function createBasePlayerVoteData(): PlayerVoteData {
  return { answer: "" };
}

export const PlayerVoteData: MessageFns<PlayerVoteData> = {
  encode(message: PlayerVoteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerVoteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerVoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerVoteData {
    return { answer: isSet(object.answer) ? globalThis.String(object.answer) : "" };
  },

  toJSON(message: PlayerVoteData): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerVoteData>): PlayerVoteData {
    return PlayerVoteData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerVoteData>): PlayerVoteData {
    const message = createBasePlayerVoteData();
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseSettings(): Settings {
  return { doubloons: 0, rounds: 0, endCondition: 0, drinking: false, family: false };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.doubloons !== 0) {
      writer.uint32(8).int32(message.doubloons);
    }
    if (message.rounds !== 0) {
      writer.uint32(16).int32(message.rounds);
    }
    if (message.endCondition !== 0) {
      writer.uint32(24).int32(message.endCondition);
    }
    if (message.drinking !== false) {
      writer.uint32(32).bool(message.drinking);
    }
    if (message.family !== false) {
      writer.uint32(40).bool(message.family);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.doubloons = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rounds = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endCondition = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.drinking = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.family = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      doubloons: isSet(object.doubloons) ? globalThis.Number(object.doubloons) : 0,
      rounds: isSet(object.rounds) ? globalThis.Number(object.rounds) : 0,
      endCondition: isSet(object.endCondition) ? globalThis.Number(object.endCondition) : 0,
      drinking: isSet(object.drinking) ? globalThis.Boolean(object.drinking) : false,
      family: isSet(object.family) ? globalThis.Boolean(object.family) : false,
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.doubloons !== 0) {
      obj.doubloons = Math.round(message.doubloons);
    }
    if (message.rounds !== 0) {
      obj.rounds = Math.round(message.rounds);
    }
    if (message.endCondition !== 0) {
      obj.endCondition = Math.round(message.endCondition);
    }
    if (message.drinking !== false) {
      obj.drinking = message.drinking;
    }
    if (message.family !== false) {
      obj.family = message.family;
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.doubloons = object.doubloons ?? 0;
    message.rounds = object.rounds ?? 0;
    message.endCondition = object.endCondition ?? 0;
    message.drinking = object.drinking ?? false;
    message.family = object.family ?? false;
    return message;
  },
};

function createBaseAdminStartData(): AdminStartData {
  return { settings: undefined };
}

export const AdminStartData: MessageFns<AdminStartData> = {
  encode(message: AdminStartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminStartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminStartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminStartData {
    return { settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined };
  },

  toJSON(message: AdminStartData): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create(base?: DeepPartial<AdminStartData>): AdminStartData {
    return AdminStartData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdminStartData>): AdminStartData {
    const message = createBaseAdminStartData();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseStartGame(): StartGame {
  return {};
}

export const StartGame: MessageFns<StartGame> = {
  encode(_: StartGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartGame {
    return {};
  },

  toJSON(_: StartGame): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StartGame>): StartGame {
    return StartGame.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StartGame>): StartGame {
    const message = createBaseStartGame();
    return message;
  },
};

function createBaseEmote(): Emote {
  return {};
}

export const Emote: MessageFns<Emote> = {
  encode(_: Emote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Emote {
    return {};
  },

  toJSON(_: Emote): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Emote>): Emote {
    return Emote.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Emote>): Emote {
    const message = createBaseEmote();
    return message;
  },
};

function createBaseRestartGame(): RestartGame {
  return {};
}

export const RestartGame: MessageFns<RestartGame> = {
  encode(_: RestartGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestartGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestartGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RestartGame {
    return {};
  },

  toJSON(_: RestartGame): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RestartGame>): RestartGame {
    return RestartGame.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RestartGame>): RestartGame {
    const message = createBaseRestartGame();
    return message;
  },
};

function createBasePhotoPickerData(): PhotoPickerData {
  return { photoAmount: 0, photoIndex: 0 };
}

export const PhotoPickerData: MessageFns<PhotoPickerData> = {
  encode(message: PhotoPickerData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photoAmount !== 0) {
      writer.uint32(8).int32(message.photoAmount);
    }
    if (message.photoIndex !== 0) {
      writer.uint32(16).int32(message.photoIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhotoPickerData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhotoPickerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.photoAmount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.photoIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhotoPickerData {
    return {
      photoAmount: isSet(object.photoAmount) ? globalThis.Number(object.photoAmount) : 0,
      photoIndex: isSet(object.photoIndex) ? globalThis.Number(object.photoIndex) : 0,
    };
  },

  toJSON(message: PhotoPickerData): unknown {
    const obj: any = {};
    if (message.photoAmount !== 0) {
      obj.photoAmount = Math.round(message.photoAmount);
    }
    if (message.photoIndex !== 0) {
      obj.photoIndex = Math.round(message.photoIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<PhotoPickerData>): PhotoPickerData {
    return PhotoPickerData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhotoPickerData>): PhotoPickerData {
    const message = createBasePhotoPickerData();
    message.photoAmount = object.photoAmount ?? 0;
    message.photoIndex = object.photoIndex ?? 0;
    return message;
  },
};

function createBaseCreateRoomRequest(): CreateRoomRequest {
  return {};
}

export const CreateRoomRequest: MessageFns<CreateRoomRequest> = {
  encode(_: CreateRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateRoomRequest {
    return {};
  },

  toJSON(_: CreateRoomRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateRoomRequest>): CreateRoomRequest {
    return CreateRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateRoomRequest>): CreateRoomRequest {
    const message = createBaseCreateRoomRequest();
    return message;
  },
};

function createBaseCreateRoomResponse(): CreateRoomResponse {
  return { roomCode: "", hostToken: "" };
}

export const CreateRoomResponse: MessageFns<CreateRoomResponse> = {
  encode(message: CreateRoomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.hostToken !== "") {
      writer.uint32(18).string(message.hostToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoomResponse {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      hostToken: isSet(object.hostToken) ? globalThis.String(object.hostToken) : "",
    };
  },

  toJSON(message: CreateRoomResponse): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.hostToken !== "") {
      obj.hostToken = message.hostToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRoomResponse>): CreateRoomResponse {
    return CreateRoomResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRoomResponse>): CreateRoomResponse {
    const message = createBaseCreateRoomResponse();
    message.roomCode = object.roomCode ?? "";
    message.hostToken = object.hostToken ?? "";
    return message;
  },
};

function createBaseJoinRoomRequest(): JoinRoomRequest {
  return { roomCode: "", playerName: "", userId: "" };
}

export const JoinRoomRequest: MessageFns<JoinRoomRequest> = {
  encode(message: JoinRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.playerName !== "") {
      writer.uint32(18).string(message.playerName);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRoomRequest {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: JoinRoomRequest): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<JoinRoomRequest>): JoinRoomRequest {
    return JoinRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoinRoomRequest>): JoinRoomRequest {
    const message = createBaseJoinRoomRequest();
    message.roomCode = object.roomCode ?? "";
    message.playerName = object.playerName ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseJoinRoomResponse(): JoinRoomResponse {
  return { playerToken: "", wasReconnection: false, snapshot: undefined };
}

export const JoinRoomResponse: MessageFns<JoinRoomResponse> = {
  encode(message: JoinRoomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerToken !== "") {
      writer.uint32(10).string(message.playerToken);
    }
    if (message.wasReconnection !== false) {
      writer.uint32(16).bool(message.wasReconnection);
    }
    if (message.snapshot !== undefined) {
      PlayerState.encode(message.snapshot, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRoomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.wasReconnection = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.snapshot = PlayerState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRoomResponse {
    return {
      playerToken: isSet(object.playerToken) ? globalThis.String(object.playerToken) : "",
      wasReconnection: isSet(object.wasReconnection) ? globalThis.Boolean(object.wasReconnection) : false,
      snapshot: isSet(object.snapshot) ? PlayerState.fromJSON(object.snapshot) : undefined,
    };
  },

  toJSON(message: JoinRoomResponse): unknown {
    const obj: any = {};
    if (message.playerToken !== "") {
      obj.playerToken = message.playerToken;
    }
    if (message.wasReconnection !== false) {
      obj.wasReconnection = message.wasReconnection;
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = PlayerState.toJSON(message.snapshot);
    }
    return obj;
  },

  create(base?: DeepPartial<JoinRoomResponse>): JoinRoomResponse {
    return JoinRoomResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoinRoomResponse>): JoinRoomResponse {
    const message = createBaseJoinRoomResponse();
    message.playerToken = object.playerToken ?? "";
    message.wasReconnection = object.wasReconnection ?? false;
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? PlayerState.fromPartial(object.snapshot)
      : undefined;
    return message;
  },
};

function createBaseGetServerTimeRequest(): GetServerTimeRequest {
  return { clientTimestamp: 0 };
}

export const GetServerTimeRequest: MessageFns<GetServerTimeRequest> = {
  encode(message: GetServerTimeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientTimestamp !== 0) {
      writer.uint32(9).double(message.clientTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerTimeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerTimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.clientTimestamp = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServerTimeRequest {
    return { clientTimestamp: isSet(object.clientTimestamp) ? globalThis.Number(object.clientTimestamp) : 0 };
  },

  toJSON(message: GetServerTimeRequest): unknown {
    const obj: any = {};
    if (message.clientTimestamp !== 0) {
      obj.clientTimestamp = message.clientTimestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServerTimeRequest>): GetServerTimeRequest {
    return GetServerTimeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerTimeRequest>): GetServerTimeRequest {
    const message = createBaseGetServerTimeRequest();
    message.clientTimestamp = object.clientTimestamp ?? 0;
    return message;
  },
};

function createBaseGetServerTimeResponse(): GetServerTimeResponse {
  return { serverTime: undefined, clientTimestamp: 0 };
}

export const GetServerTimeResponse: MessageFns<GetServerTimeResponse> = {
  encode(message: GetServerTimeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverTime !== undefined) {
      Timestamp.encode(toTimestamp(message.serverTime), writer.uint32(10).fork()).join();
    }
    if (message.clientTimestamp !== 0) {
      writer.uint32(17).double(message.clientTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerTimeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerTimeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.clientTimestamp = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServerTimeResponse {
    return {
      serverTime: isSet(object.serverTime) ? fromJsonTimestamp(object.serverTime) : undefined,
      clientTimestamp: isSet(object.clientTimestamp) ? globalThis.Number(object.clientTimestamp) : 0,
    };
  },

  toJSON(message: GetServerTimeResponse): unknown {
    const obj: any = {};
    if (message.serverTime !== undefined) {
      obj.serverTime = message.serverTime.toISOString();
    }
    if (message.clientTimestamp !== 0) {
      obj.clientTimestamp = message.clientTimestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServerTimeResponse>): GetServerTimeResponse {
    return GetServerTimeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerTimeResponse>): GetServerTimeResponse {
    const message = createBaseGetServerTimeResponse();
    message.serverTime = object.serverTime ?? undefined;
    message.clientTimestamp = object.clientTimestamp ?? 0;
    return message;
  },
};

function createBaseGameEvent(): GameEvent {
  return { event: undefined };
}

export const GameEvent: MessageFns<GameEvent> = {
  encode(message: GameEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.event?.$case) {
      case "fullSync":
        RoomState.encode(message.event.fullSync, writer.uint32(10).fork()).join();
        break;
      case "playerUpdate":
        PlayerState.encode(message.event.playerUpdate, writer.uint32(18).fork()).join();
        break;
      case "connectionChange":
        ConnectionChange.encode(message.event.connectionChange, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = { $case: "fullSync", fullSync: RoomState.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = { $case: "playerUpdate", playerUpdate: PlayerState.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.event = {
            $case: "connectionChange",
            connectionChange: ConnectionChange.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEvent {
    return {
      event: isSet(object.fullSync)
        ? { $case: "fullSync", fullSync: RoomState.fromJSON(object.fullSync) }
        : isSet(object.playerUpdate)
          ? { $case: "playerUpdate", playerUpdate: PlayerState.fromJSON(object.playerUpdate) }
          : isSet(object.connectionChange)
            ? { $case: "connectionChange", connectionChange: ConnectionChange.fromJSON(object.connectionChange) }
            : undefined,
    };
  },

  toJSON(message: GameEvent): unknown {
    const obj: any = {};
    if (message.event?.$case === "fullSync") {
      obj.fullSync = RoomState.toJSON(message.event.fullSync);
    } else if (message.event?.$case === "playerUpdate") {
      obj.playerUpdate = PlayerState.toJSON(message.event.playerUpdate);
    } else if (message.event?.$case === "connectionChange") {
      obj.connectionChange = ConnectionChange.toJSON(message.event.connectionChange);
    }
    return obj;
  },

  create(base?: DeepPartial<GameEvent>): GameEvent {
    return GameEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameEvent>): GameEvent {
    const message = createBaseGameEvent();
    switch (object.event?.$case) {
      case "fullSync": {
        if (object.event?.fullSync !== undefined && object.event?.fullSync !== null) {
          message.event = { $case: "fullSync", fullSync: RoomState.fromPartial(object.event.fullSync) };
        }
        break;
      }
      case "playerUpdate": {
        if (object.event?.playerUpdate !== undefined && object.event?.playerUpdate !== null) {
          message.event = { $case: "playerUpdate", playerUpdate: PlayerState.fromPartial(object.event.playerUpdate) };
        }
        break;
      }
      case "connectionChange": {
        if (object.event?.connectionChange !== undefined && object.event?.connectionChange !== null) {
          message.event = {
            $case: "connectionChange",
            connectionChange: ConnectionChange.fromPartial(object.event.connectionChange),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePlayerInput(): PlayerInput {
  return { playerName: "", input: undefined };
}

export const PlayerInput: MessageFns<PlayerInput> = {
  encode(message: PlayerInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerName !== "") {
      writer.uint32(10).string(message.playerName);
    }
    if (message.input !== undefined) {
      PlayerInputPayload.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = PlayerInputPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerInput {
    return {
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      input: isSet(object.input) ? PlayerInputPayload.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: PlayerInput): unknown {
    const obj: any = {};
    if (message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.input !== undefined) {
      obj.input = PlayerInputPayload.toJSON(message.input);
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerInput>): PlayerInput {
    return PlayerInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerInput>): PlayerInput {
    const message = createBasePlayerInput();
    message.playerName = object.playerName ?? "";
    message.input = (object.input !== undefined && object.input !== null)
      ? PlayerInputPayload.fromPartial(object.input)
      : undefined;
    return message;
  },
};

function createBaseRoomState(): RoomState {
  return { roomCode: "", stage: 0, players: [] };
}

export const RoomState: MessageFns<RoomState> = {
  encode(message: RoomState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.stage !== 0) {
      writer.uint32(16).int32(message.stage);
    }
    for (const v of message.players) {
      PlayerState.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stage = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.players.push(PlayerState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomState {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      stage: isSet(object.stage) ? gameStageFromJSON(object.stage) : 0,
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => PlayerState.fromJSON(e)) : [],
    };
  },

  toJSON(message: RoomState): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.stage !== 0) {
      obj.stage = gameStageToJSON(message.stage);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => PlayerState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RoomState>): RoomState {
    return RoomState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomState>): RoomState {
    const message = createBaseRoomState();
    message.roomCode = object.roomCode ?? "";
    message.stage = object.stage ?? 0;
    message.players = object.players?.map((e) => PlayerState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnectionChange(): ConnectionChange {
  return { playerName: "", userId: "", isConnected: false };
}

export const ConnectionChange: MessageFns<ConnectionChange> = {
  encode(message: ConnectionChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerName !== "") {
      writer.uint32(10).string(message.playerName);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.isConnected !== false) {
      writer.uint32(24).bool(message.isConnected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isConnected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionChange {
    return {
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      isConnected: isSet(object.isConnected) ? globalThis.Boolean(object.isConnected) : false,
    };
  },

  toJSON(message: ConnectionChange): unknown {
    const obj: any = {};
    if (message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.isConnected !== false) {
      obj.isConnected = message.isConnected;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionChange>): ConnectionChange {
    return ConnectionChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionChange>): ConnectionChange {
    const message = createBaseConnectionChange();
    message.playerName = object.playerName ?? "";
    message.userId = object.userId ?? "";
    message.isConnected = object.isConnected ?? false;
    return message;
  },
};

function createBaseUpdatePlayerStateRequest(): UpdatePlayerStateRequest {
  return { updates: {} };
}

export const UpdatePlayerStateRequest: MessageFns<UpdatePlayerStateRequest> = {
  encode(message: UpdatePlayerStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.updates).forEach(([key, value]) => {
      UpdatePlayerStateRequest_UpdatesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePlayerStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePlayerStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = UpdatePlayerStateRequest_UpdatesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.updates[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePlayerStateRequest {
    return {
      updates: isObject(object.updates)
        ? Object.entries(object.updates).reduce<{ [key: string]: PlayerState }>((acc, [key, value]) => {
          acc[key] = PlayerState.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdatePlayerStateRequest): unknown {
    const obj: any = {};
    if (message.updates) {
      const entries = Object.entries(message.updates);
      if (entries.length > 0) {
        obj.updates = {};
        entries.forEach(([k, v]) => {
          obj.updates[k] = PlayerState.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePlayerStateRequest>): UpdatePlayerStateRequest {
    return UpdatePlayerStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePlayerStateRequest>): UpdatePlayerStateRequest {
    const message = createBaseUpdatePlayerStateRequest();
    message.updates = Object.entries(object.updates ?? {}).reduce<{ [key: string]: PlayerState }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PlayerState.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUpdatePlayerStateRequest_UpdatesEntry(): UpdatePlayerStateRequest_UpdatesEntry {
  return { key: "", value: undefined };
}

export const UpdatePlayerStateRequest_UpdatesEntry: MessageFns<UpdatePlayerStateRequest_UpdatesEntry> = {
  encode(message: UpdatePlayerStateRequest_UpdatesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PlayerState.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePlayerStateRequest_UpdatesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePlayerStateRequest_UpdatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PlayerState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePlayerStateRequest_UpdatesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PlayerState.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UpdatePlayerStateRequest_UpdatesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PlayerState.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePlayerStateRequest_UpdatesEntry>): UpdatePlayerStateRequest_UpdatesEntry {
    return UpdatePlayerStateRequest_UpdatesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePlayerStateRequest_UpdatesEntry>): UpdatePlayerStateRequest_UpdatesEntry {
    const message = createBaseUpdatePlayerStateRequest_UpdatesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PlayerState.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { targetPlayer: "", message: "" };
}

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  encode(message: SendMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetPlayer !== "") {
      writer.uint32(10).string(message.targetPlayer);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetPlayer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      targetPlayer: isSet(object.targetPlayer) ? globalThis.String(object.targetPlayer) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.targetPlayer !== "") {
      obj.targetPlayer = message.targetPlayer;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<SendMessageRequest>): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendMessageRequest>): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.targetPlayer = object.targetPlayer ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSetGameStageRequest(): SetGameStageRequest {
  return { roomCode: "", hostToken: "", stage: 0 };
}

export const SetGameStageRequest: MessageFns<SetGameStageRequest> = {
  encode(message: SetGameStageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.hostToken !== "") {
      writer.uint32(18).string(message.hostToken);
    }
    if (message.stage !== 0) {
      writer.uint32(24).int32(message.stage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGameStageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGameStageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stage = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGameStageRequest {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      hostToken: isSet(object.hostToken) ? globalThis.String(object.hostToken) : "",
      stage: isSet(object.stage) ? gameStageFromJSON(object.stage) : 0,
    };
  },

  toJSON(message: SetGameStageRequest): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.hostToken !== "") {
      obj.hostToken = message.hostToken;
    }
    if (message.stage !== 0) {
      obj.stage = gameStageToJSON(message.stage);
    }
    return obj;
  },

  create(base?: DeepPartial<SetGameStageRequest>): SetGameStageRequest {
    return SetGameStageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetGameStageRequest>): SetGameStageRequest {
    const message = createBaseSetGameStageRequest();
    message.roomCode = object.roomCode ?? "";
    message.hostToken = object.hostToken ?? "";
    message.stage = object.stage ?? 0;
    return message;
  },
};

function createBaseSendPlayerInputRequest(): SendPlayerInputRequest {
  return { roomCode: "", playerToken: "", input: undefined };
}

export const SendPlayerInputRequest: MessageFns<SendPlayerInputRequest> = {
  encode(message: SendPlayerInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.playerToken !== "") {
      writer.uint32(18).string(message.playerToken);
    }
    if (message.input !== undefined) {
      PlayerInputPayload.encode(message.input, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPlayerInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPlayerInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = PlayerInputPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPlayerInputRequest {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      playerToken: isSet(object.playerToken) ? globalThis.String(object.playerToken) : "",
      input: isSet(object.input) ? PlayerInputPayload.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: SendPlayerInputRequest): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.playerToken !== "") {
      obj.playerToken = message.playerToken;
    }
    if (message.input !== undefined) {
      obj.input = PlayerInputPayload.toJSON(message.input);
    }
    return obj;
  },

  create(base?: DeepPartial<SendPlayerInputRequest>): SendPlayerInputRequest {
    return SendPlayerInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendPlayerInputRequest>): SendPlayerInputRequest {
    const message = createBaseSendPlayerInputRequest();
    message.roomCode = object.roomCode ?? "";
    message.playerToken = object.playerToken ?? "";
    message.input = (object.input !== undefined && object.input !== null)
      ? PlayerInputPayload.fromPartial(object.input)
      : undefined;
    return message;
  },
};

function createBaseLeaveRoomRequest(): LeaveRoomRequest {
  return { roomCode: "", playerToken: "" };
}

export const LeaveRoomRequest: MessageFns<LeaveRoomRequest> = {
  encode(message: LeaveRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomCode !== "") {
      writer.uint32(10).string(message.roomCode);
    }
    if (message.playerToken !== "") {
      writer.uint32(18).string(message.playerToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveRoomRequest {
    return {
      roomCode: isSet(object.roomCode) ? globalThis.String(object.roomCode) : "",
      playerToken: isSet(object.playerToken) ? globalThis.String(object.playerToken) : "",
    };
  },

  toJSON(message: LeaveRoomRequest): unknown {
    const obj: any = {};
    if (message.roomCode !== "") {
      obj.roomCode = message.roomCode;
    }
    if (message.playerToken !== "") {
      obj.playerToken = message.playerToken;
    }
    return obj;
  },

  create(base?: DeepPartial<LeaveRoomRequest>): LeaveRoomRequest {
    return LeaveRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaveRoomRequest>): LeaveRoomRequest {
    const message = createBaseLeaveRoomRequest();
    message.roomCode = object.roomCode ?? "";
    message.playerToken = object.playerToken ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
